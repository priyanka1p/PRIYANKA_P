**********************************************************************
using ObservedObject
**********************************************************************
import SwiftUI
import Observation

class Counter:ObservableObject{
    @Published var count:Int// only when Published is present, swift monitors and notifies of any change of this property.
    func increment(){
        count += 1
    }
    init(count:Int){
        self.count = count
    }
    init(){
        count = 1
    }
}

struct ContentView: View {
    @StateObject var counter:Counter
    //let c = Counter(count: 26) //  in order to re render while clicking button it should be observed via StateObject or ObservedObject
    init(arg1 : Int) {
        _counter = StateObject(wrappedValue: Counter(count: arg1))
    }
    var body: some View {
        print(counter.count)
        //counter = Counter()//@StateObject is designed to be initialized only once, and its reference cannot be reassigned from within the view.
        
       
        return VStack{
            Spacer()
            VStack {
                Text("\(counter.count)")
                    .font(.title)
                Button("Increment") {
                    self.counter.increment()
                }.font(.largeTitle)
            }
            Spacer()
            AddToList(add: counter)
            Spacer()
        }
    }
}


struct AddToList:View{
    @ObservedObject var add: Counter // here add is immutable
    var body: some View{
        print(add.count)
        print("addto list is called")
        
        return Text("Added \(add.count) item to cart")
    }
}

#Preview {
    ContentView(arg1: 50)
}
**********************************************************************
//using EnvironmentObject
**********************************************************************
import SwiftUI
import Observation

class Counter:ObservableObject{
    @Published var count:Int // only when Published is present, swift monitors and notifies of any change of this property.
    func increment(){
        count += 1
    }
    init(count:Int){
        self.count = count
    }
    init(){
        count = 1
    }
}

struct ContentView: View {
    @StateObject var counter:Counter
    //let c = Counter(count: 26) //  in order to re render while clicking button it should be observed via StateObject or ObservedObject
    init(arg1 : Int) {
        _counter = StateObject(wrappedValue: Counter(count: arg1))
    }
    var body: some View {
        print(counter.count)
        //counter = Counter()//@StateObject is designed to be initialized only once, and its reference cannot be reassigned from within the view.
        
       
        return VStack{
            Spacer()
            VStack {
                Text("\(counter.count)")
                    .font(.title)
                Button("Increment") {
                    self.counter.increment()
                }.font(.largeTitle)
            }
            Spacer()
            AddToList()
                .environmentObject(counter)
            Spacer()
            
        }
    }
}
struct AddToList:View{
    @EnvironmentObject var add: Counter // here add is immutable
    var body: some View{
        print($add.count)
        print("addto list is called")
        
//        Use $ only with property wrappers that project a binding (like @State, @Binding, @FocusState).
//        With @ObservedObject, @StateObject, @EnvironmentObject â†’ access properties directly (object.property).
        return Text("Added \($add.count) \n item to cart \(add.count)")
    }
}

#Preview {
    ContentView(arg1: 50)
}
**********************************************************************
